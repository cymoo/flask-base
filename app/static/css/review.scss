@charset "UTF-8";
// Author: Cymoo
// Date:   2018-03-06
// Source: http://sass-lang.com/documentation/file.SASS_REFERENCE.html
// Description: This file lists most of the rules and syntax for scss

/*******************************
Output Style
*******************************/

// nested
#main {
  color: #fff;
  background-color: #000; }
  #main p {
    width: 10em; }

// expanded
#main {
  color: #fff;
  background-color: #000;
}
#main p {
  width: 10em;
}

// compact
#main { color: #fff; background-color: #000; }
#main p { width: 10em; }


// compressed
// #main{color:#fff;background-color:#000}#main p{width:10em}

/**********************************
Nested Rules
**********************************/

#main p {
  color: #333;
  width: 80%;

  .redbox {
    background-color: #fff;
    color: #555;
  }
}

// Referencing Parent Selectors: &
a {
  font-weight: bold;

  &:hover {
    text-decoration: none;
  }

  body.firefox & {
    font-weight: normal;
  }
}

#main {
  color: black;
  
  // & must appear at the beginning of a compound selector
  &-sidebar {
    border: 1px solid;
  }
}

// Nested Properties
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}

//.funky {
//  font:20px/24px fantasy {
//    weight: bold;
//  }
//}
// Placeholder Selectors
%foo {
  color: #999;
}
/**********************************
Variables
**********************************/
$width: 5em;

#main {
  width: $width;
}

#main {
  $width1: 7rem !global;
  width: $width1;
}

#sidebar {
  width: $width1;
}
/**********************************
Date Types
* numbers (1.2, 13, 10px)
* strings of text, with and without quotes ("foo", 'bar', baz)
* colors (blue, #fff, rgba(0,0,0,.7)
* booleans (true, false)
* nulls (null)
* list of values, separated by spaces or commas (1.5rem 1rem, Helvetica, Arial, sans-serif)
* maps from one value to another (key1: value1, key2: value2)
* function references
**********************************/
// Strings
@mixin firefox-message($selector) {
  body.firefox #{$selector}:before {
    content: "Hi, firefox users!";
  }
}
// @include firefox-message(".header")
// Lists
// 1px 2px, 5px 6px is a two-item list containing the list 1px 2px and the list 5px 6px.
/**********************************
Operations
**********************************/
// division
p {
  font: 10px/8px;
  // Plain CSS, no division
  $width: 1000px;
  width: $width/2;
  // Uses a variable, does division
  width: round(1.5)/2;
  // Uses a function, does division
  height: (500px/2);
  // Uses parentheses, does division
  margin-left: 5px + 8px/2px; // Uses +, does division
  font: (italic bold 10px/8px); // In a list, parentheses don't count
}
// color operation
p {
  color: #010203 + #040506;
}

p {
  color: #010203 * 2;
}

p {
  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
}
// string operation
p {
  cursor: e + -resize;
}

p:before {
  content: "Foo " + Bar;
  font-family: sans- + "serif";
}

p {
  margin: 3px + 4 px auto;
}

p:before {
  content: "I ate #{5 + 10} pies";
}

p {
  $value: null;
  // null values are treated as empty strings for string interpolation.
  &:before {
    content: "I ate #{$value} pies!";
  }
}
// boolean operation
// sassScript supports and, or, and not operators for boolean values.
// parentheses
p {
  width: 1em + (2em * 3);
}
// functions
p {
  color: hsl(0, 100%, 50%);
}
// with explicit keywords

p {
  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
}
// interpolation
// in selectors and property names
$name: foo;
$attr: border;

p.#{$name} {
  #{$attr}-color: blue;
}
// in property values.
// using #{} does mean that any operations near it will be treated as plain CSS.

p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
}
// & in SassScript
.bip.qux,
.foo.bar .baz.bang {
  $selector: &;
}
@mixin does-parent-exist {
  @if & {
    &:hover {
      color: red;
    }
  } @else {
    a {
      color: red;
    }
  }
}
// variable default: !default
$content: "First content";
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  content: $content;
  new-content: $new_content;
}
// Variables with null values are treated as unassigned by !default
$content: null;
$content: "Non-null content" !default;

#main {
  content: $content;
}
/**********************************
@-Rules and Directives
**********************************/
/**********************************
@import
**********************************/
// partial import
// _foo.scss
// nested import
// Directives that are only allowed at the base level of a document,
// like @mixin or @charset, are not allowed in files that are @imported in a nested context.
// It's not possible to nest @import within mixins or control directives.
/**********************************
@media
**********************************/
// nested
.sidebar {
  width: 300px;
  @media screen and (orientation: landscape) {
    width: 500px;
  }
}
// nested within one another; will be combined using the and operator
@media screen {
  .sidebar {
    @media (orientation: landscape) {
      width: 500px;
    }
  }
}
// can contain SassScript expression
$media: screen;
$feature: -webkit-min-device-pixel-ratio;
$value: 1.5;
@media #{$media} and ($feature: $value) {
  .sidebar {
    width: 500px;
  }
}
/**********************************
@extend
**********************************/

// 能用mixin就不用extend (**永远不要使用extend**)
// 原因：
// 1. @extend 会改变了你的源命令，这在CSS中是相当危险的
// 2. @extend 会破坏代码结构合理性，把不相关的选择器串联到一起
// 3. @extend 是非常贪婪的，它会包含一切的代码，而不仅仅是你想要的那一个
// 4. @extend 可能会很快就脱离我们控制
// https://www.sass.hk/skill/sass143.html
// https://www.sass.hk/skill/sass141.html
.error {
  border: 1px #f00;
  background-color: #fdd;
}

.error.intrusion {
  background-image: url("/image/hacked.png");
}
// Other rules that use .error will work for .seriousError as well
// .seriousError.intrusion will also be generated

.seriousError {
  @extend .error;
  border-width: 3px;
}
// extends complex selectors
// selectors like .special.cool, a:hover, or a.user[href^="http://"] ... can also be extended

//.hoverlink {
//  @extend a: hover;
//}

a:hover {
  text-decoration: underline;
}
// multiple extends
// chaining extends
// Selector sequences, such as .foo .bar or .foo + .bar, currently can't be extended.

#fake-links .link {
  @extend a;
}

a {
  color: blue;

  &:hover {
    text-decoration: underline;
  }
}
// Merging Selector Sequences
// When the two sequences being merged have no selectors in common,
// then two new selectors are generated: one with the first sequence before the second,
// and one with the second sequence before the first.
// NOTE: 不是好规则，尽量不要使用此类selector

#admin .tabbar a {
  font-weight: bold;
}

#demo .overview .fakelink {
  @extend a;
}
// If the two sequences do share some selectors,
// then those selectors will be merged together and only the differences
// (if any still exist) will alternate.
// NOTE: 尽量不要使用

#admin .tabbar a {
  font-weight: bold;
}

#admin .overview .fakelink {
  @extend a;
}
// Placeholder selectors
// This ruleset won't be rendered on its own.

#context a%extreme {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}

.notice {
  @extend %extreme;
}
// The !optional Flag
/*
Normally when you extend a selector, it's an error if that @extend doesn't work.
For example, if you write a.important {@extend .notice},
it's an error if there are no selectors that contain .notice.
It's also an error if the only selector containing .notice is h1.notice,
since h1 conflicts with a and so no new selector would be generated.
Sometimes, though, you want to allow an @extend not to produce any new selectors.
To do so, just add the !optional flag after the selector.
*/
a.important {
  @extend .notice !optional;
}
// @extend in Directives
/*
There are some restrictions on the use of @extend within directives such as @media.
Sass is unable to make CSS rules outside of the @media block apply to selectors inside it
without creating a huge amount of stylesheet bloat by copying styles all over the place.
This means that if you use @extend within @media (or other CSS directives),
you may only extend selectors that appear within the same directive block.
NOTE: 尽量不要使用此规则
 */
// the following works fine
//@media print {
//  .error {
//    border: 1px #f00;
//    background-color: #fdd;
//  }
//  .seriousError {
//    @extend .error;
//    border-width: 3px;
//  }
//}
// this is an error
//.error {
//  border: 1px #f00;
//  background-color: #fdd;
//}
//@media print {
//  .seriousError {
//    // INVALID EXTEND: .error is used outside of the "@media print" directive
//    @extend .error;
//    border-width: 3px;
//  }
//}
// @at-root
// TODO: @at-root的使用场景，用于BEM??
// By default, @at-root just excludes selectors.
// However, it's also possible to use @at-root to move outside of nested directives
// such as @media as well
@media print {
  .page {
    width: 8in;
    @at-root (without: media) {
      color: red;
    }
  }
}
/**********************************
@debug @warn @error
**********************************/
// @debug
// @debug 10em  + 12em
// @warn
/*
 1. You can turn warnings off with the --quiet command-line option or the :quiet Sass option.
 2. A stylesheet trace will be printed out along with the message
    so that the user being warned can see where their styles caused the warning.
*/
@mixin adjust-location($x, $y) {
  @if unitless($x) {
    @warn "Assuming #{$x} to be in pixels";
    $x: 1px * $x;
  }
  @if unitless($y) {
    @warn "Assuming #{$y} to be in pixels";
    $y: 1px * $y;
  }
  position: relative;
  left: $x;
  top: $y;
}
// @error
/*
The @error directive throws the value of a SassScript expression as a fatal error
including a nice stack trace. It's useful for validating arguments to mixins and functions.
There is currently no way to catch errors.
*/
@mixin adjust-location($x, $y) {
  @if unitless($x) {
    @error "$x may not be unitless, was #{$x}.";
  }
  @if unitless($y) {
    @error "$y may not be unitless, was #{$y}.";
  }
  position: relative;
  left: $x;
  top: $y;
}

.bar {
  @include adjust-location(13px, 15px)
}
/*******************************
Control directives & expressions
*******************************/
// @if
/*
The @if directive takes a SassScript expression and uses the styles nested beneath it
if the expression returns anything other than false or null
You can explicitly test for $var == false or $var == null
if you want to distinguish between these.
*/
p {
  @if 1 + 1 == 2 {
    border: 1px solid;
  }
  @if 5 < 3 {
    border: 2px dotted;
  }
  @if null {
    border: 3px double;
  }
}
$type: monster;

p {
  @if $type == ocean {
    color: blue;
  } @else
  if $type == matador {
    color: red;
  } @else
  if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
// @for
/*
The @for directive repeatedly outputs a set of styles. For each repetition,
a counter variable is used to adjust the output.
The directive has two forms: @for $var from <start> through <end> and @for $var from <start> to <end>.
please note the difference in the keywords through and to. $var can be any variable name, like $i;
<start> and <end> are SassScript expressions that should return integers.
When <start> is greater than <end> the counter will decrement instead of increment.

The @for statement sets $var to each successive number in the specified range
and each time outputs the nested styles using that value of $var.
For the form from ... through, the range includes the values of <start> and <end>,
but the form from ... to runs up to but not including the value of <end>.
*/
@for $i from 1 through 3 {
  .item-#{$i} {
    width: 2em * $i;
  }
}
// @each
/*
The @each directive usually has the form @each $var in <list or map>.
$var can be any variable name, like $length or $name,
and <list or map> is a SassScript expression that returns a list or a map.

The @each rule sets $var to each item in the list or map,
then outputs the styles it contains using that value of $var.
*/
@each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url("/images/#{$animal}.png");
  }
}
// multiple assignment
/*
The @each directive can also use multiple variables, as in @each $var1, $var2, ... in <list>.
If <list> is a list of lists, each element of the sub-lists is assigned to the respective variable
*/
@each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) {
  .#{$animal}-icon {
    background-image: url("/images/#{$animal}.png");
    border: 2px solid $color;
    cursor: $cursor;
  }
}
// Since maps are treated as lists of pairs, multiple assignment works with them as well.
@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
  #{$header} {
    font-size: $size;
  }
}
// @while
/*
The @while directive takes a SassScript expression and repeatedly outputs the nested styles
until the statement evaluates to false.
This can be used to achieve more complex looping than the @for statement is capable of,
although this is rarely necessary.
*/
$i: 6;
@while $i > 0 {
  .item-#{$i} {
    width: 2em * $i;
  }
  $i: $i - 2;
}
/*******************************
@mixin
*******************************/
@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}
// Mixins may also contain selectors, possibly mixed with properties.
// The selectors can even contain parent references.
@mixin clearfix {
  display: inline-block;

  &:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
  }

  * html & {
    height: 1px;
  }
}
// @include
.baz {
  @include clearfix;
}
// Mixins may also be included outside of any rule (that is, at the root of the document)
// as long as they don't directly define any properties or use any parent references.
@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}
@include silly-links;
// Mixin definitions can also include other mixins
@mixin highlighted-background {
  background-color: #fc0;
}
@mixin header-text {
  font-size: 20px;
}
@mixin compound {
  @include highlighted-background;
  @include header-text;
}
// arguments
@mixin sexy-border($color, $width) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}

p {
  @include sexy-border(blue, 3px);
}
// default arguments
@mixin sexy-border($color, $width: 1in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}

p {
  @include sexy-border(blue);
}

h1 {
  @include sexy-border(blue, 2in);
}
// keywords arguments
p {
  @include sexy-border($color: blue);
}

h1 {
  @include sexy-border($color: blue, $width: 2in);
}
// variable arguments
/*
arguments at the end of a mixin or function declaration
that take all leftover arguments and package them up as a list.
These arguments look just like normal arguments, but are followed by ...
*/
@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}

.shadows {
  @include box-shadow(0 4px 5px #666, 2px 6px 10px #999);
}
/*
you can expand a list of values so that each value is passed as a separate argument,
or expand a map of values so that each pair is treated as a keyword argument.
*/
@mixin colors($text, $background, $border) {
  color: $text;
  background-color: $background;
  border-color: $border;
}
$values: #ff0000, #00ff00, #0000ff;

.primary {
  @include colors($values...);
}
$value-map: (
  text: #00ff00,
  background: #0000ff,
  border: #ff0000
);

.secondary {
  @include colors($value-map...);
}
/*
You can use variable arguments to wrap a mixin and add additional styles
without changing the argument signature of the mixin.
If you do, keyword arguments will get directly passed through to the wrapped mixin.
NOTE: 类似于Python的被装饰的函数
*/
// Passing Content Blocks to a Mixin
/*
It is possible to pass a block of styles to the mixin for placement
within the styles included by the mixin.
The styles will appear at the location of any @content directives found within the mixin.
This makes it possible to define abstractions relating to the construction of selectors
and directives.
when the @content directive is specified more than once or in a loop,
the style block will be duplicated with each invocation.
The content-exists() function will return true when a content block
is passed to the current mixin and can be used to implement such behaviors.
NOTE: 具体使用场景？
*/
@mixin apply-to-ie6-only {
  * html {
    @content;
  }
}
@include apply-to-ie6-only {
  #logo {
    background-image: url("/logo.gif");
  }
}
// Variable Scope and Content Blocks
/*
The block of content passed to a mixin are evaluated in the scope
where the block is defined, not in the scope of the mixin.
This means that variables local to the mixin cannot be used within the passed style block
and variables will resolve to the global value.
NOTE: 词法作用域
*/
$color: white;
@mixin colors($color: blue) {
  background-color: $color;
  @content;
  border-color: $color;
}

.colors {
  @include colors {
    color: $color;
  }
}
/*******************************
Function Directives
*******************************/
// @return must be called to set the return value of the function
// function behaves like mixin in many aspects, like keywords arguments, variable arguments
/*
It is recommended that you prefix your functions to avoid naming conflicts and
so that readers of your stylesheets know they are not part of Sass or CSS.
*/
$grid-width: 40px;
$gutter-width: 10px;
@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar {
  width: grid-width(5);
}
